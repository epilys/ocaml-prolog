<!DOCTYPE HTML>
<html>
  <head>
    <title>prolog interpreter in ocaml</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link href="./style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="page">
      <div id="header">
        <div class="page-title">prolog interpreter in ocaml</div>
      </div>
      <div class="date">June 14, 2016</div>
      
<div class="img-float-right"><img class="img" src="term.gif" width=""/><div class="legend"><a href="test.pl">test.pl</a> and <a href="prog.pl">prog.pl</a></div></div>

<h2> imperative vs functional</h2>
<h3> imperative</h3>
<p>In a typical interpreter Prolog is most usually compiled into instructions of an abstract model called the Warren Abstract Machine. Then the instructions are executed in a WAM implementation inside the interpreter. WAM is imperative ; it contains mutable structures and commands to be executed. A detailed explanation can be found <a href="http://wambook.sourceforge.net/">here</a>.</p>
<h3> functional</h3>
<p>OCaml is multi-paradigm, but we choose to implement an interpreter in a functional manner. As we can't directly work with the WAM, we will work directly on Prolog terms instead.</p>
<h2> the implementation</h2>
<p>Our interpreter should be able to understand Prolog terms by reading queries from a prompt and by reading Prolog program files, parsing them and asserting them in its database. The database will simply be a hash table of predicates containing the loaded programs, converting, for example, the following program:</p>

<pre class="code-pro"><span class="hl kwd">mother_child</span><span class="hl opt">(</span>trude<span class="hl opt">,</span> sally<span class="hl opt">).</span>
 
<span class="hl kwd">father_child</span><span class="hl opt">(</span>tom<span class="hl opt">,</span> sally<span class="hl opt">).</span>
<span class="hl kwd">father_child</span><span class="hl opt">(</span>tom<span class="hl opt">,</span> erica<span class="hl opt">).</span>
<span class="hl kwd">father_child</span><span class="hl opt">(</span>mike<span class="hl opt">,</span> tom<span class="hl opt">).</span>
 
<span class="hl kwd">sibling</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">)      :-</span> <span class="hl kwd">parent_child</span><span class="hl opt">(</span>Z<span class="hl opt">,</span> X<span class="hl opt">),</span> <span class="hl kwd">parent_child</span><span class="hl opt">(</span>Z<span class="hl opt">,</span> Y<span class="hl opt">).</span>
 
<span class="hl kwd">parent_child</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">) :-</span> <span class="hl kwd">father_child</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">).</span>
<span class="hl kwd">parent_child</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">) :-</span> <span class="hl kwd">mother_child</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">).</span></pre>
<p>to</p>
<pre class="code-txt"><span class="hl std">&quot;mother_child/2&quot;    -&gt;  mother_child(trude, sally).
&quot;father_child/2&quot;    -&gt;  father_child(tom, sally).
                        father_child(tom, erica).
[..]
&quot;sibling/2&quot;         -&gt;  sibling(X, Y) :- parent_child(Z,X), parent_child(Z,Y).
[..]
</span></pre>
<p>
We begin by writing Prolog's simple grammar rules in the form of regular expression annotations that will be read by ocamllex to generate a lexical analyzer of Prolog. Essentially, the analyzer will recognize Prolog structures like clauses, variables, constants, atoms, and then we will use them to construct OCaml types with which we will work.</p>
<pre class="code-ocaml"><span class="hl kwa">let</span><span class="hl std"> </span><span class="">whitespace</span><span class="hl std"> = [ </span><span class="hl str">' '</span><span class="hl std"> </span><span class="hl str">'\t'</span><span class="hl std">]+
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">newline</span><span class="hl std"> = </span><span class="hl str">'\r'</span><span class="hl std"> | </span><span class="hl str">'\n'</span><span class="hl std"> | </span><span class="hl str">&quot;\r\n&quot;</span><span class="hl std">
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">constant</span><span class="hl std"> = [</span><span class="hl str">'a'</span><span class="hl std"> - </span><span class="hl str">'z'</span><span class="hl std"> </span><span class="hl str">'_'</span><span class="hl std">] [</span><span class="hl str">'a'</span><span class="hl std">-</span><span class="hl str">'z'</span><span class="hl std"> </span><span class="hl str">'A'</span><span class="hl std">-</span><span class="hl str">'Z'</span><span class="hl std"> </span><span class="hl str">'0'</span><span class="hl std">-</span><span class="hl str">'9'</span><span class="hl std"> </span><span class="hl str">'_'</span><span class="hl std">]*
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">variable</span><span class="hl std"> = [</span><span class="hl str">'A'</span><span class="hl std">-</span><span class="hl str">'Z'</span><span class="hl std">] [</span><span class="hl str">'a'</span><span class="hl std">-</span><span class="hl str">'z'</span><span class="hl std"> </span><span class="hl str">'A'</span><span class="hl std">-</span><span class="hl str">'Z'</span><span class="hl std"> </span><span class="hl str">'0'</span><span class="hl std">-</span><span class="hl str">'9'</span><span class="hl std"> </span><span class="hl str">'_'</span><span class="hl std">]*

</span><span class="">rule</span><span class="hl std"> </span><span class="">token</span><span class="hl std"> = </span><span class="">parse</span><span class="hl std"> 
    | </span><span class="">whitespace</span><span class="hl std"> { </span><span class="">token</span><span class="hl std"> </span><span class="">lexbuf</span><span class="hl std"> }
    | </span><span class="">newline</span><span class="hl std"> { </span><span class="">next_line</span><span class="hl std"> </span><span class="">lexbuf</span><span class="hl std"> ; </span><span class="">token</span><span class="hl std"> </span><span class="">lexbuf</span><span class="hl std"> }
    | </span><span class="">variable</span><span class="hl std"> </span><span class="hl kwb">as</span><span class="hl std"> </span><span class="">v</span><span class="hl std"> { </span><span class="hl kwc">VAR</span><span class="hl std"> </span><span class="">v</span><span class="hl std"> }
    | </span><span class="">constant</span><span class="hl std"> </span><span class="hl kwb">as</span><span class="hl std"> </span><span class="">v</span><span class="hl std"> { </span><span class="hl kwc">CONST</span><span class="hl std"> </span><span class="">v</span><span class="hl std"> }
    | </span><span class="hl str">'('</span><span class="hl std"> { </span><span class="hl kwc">LPAREN</span><span class="hl std">  }
    | </span><span class="hl str">')'</span><span class="hl std"> { </span><span class="hl kwc">RPAREN</span><span class="hl std"> }
    | </span><span class="hl str">':'</span><span class="hl std"> { </span><span class="hl kwc">COLON</span><span class="hl std">  }
    | </span><span class="hl str">'-'</span><span class="hl std"> { </span><span class="hl kwc">DASH</span><span class="hl std"> }
    | </span><span class="hl str">'.'</span><span class="hl std"> { </span><span class="hl kwc">PERIOD</span><span class="hl std">  }
    | </span><span class="hl str">','</span><span class="hl std"> { </span><span class="hl kwc">COMMA</span><span class="hl std"> }
    | </span><span class="hl str">'['</span><span class="hl std"> { </span><span class="hl kwc">LBRACKET</span><span class="hl std"> }
    | </span><span class="hl str">']'</span><span class="hl std"> { </span><span class="hl kwc">RBRACKET</span><span class="hl std"> }
    | </span><span class="hl str">'\''</span><span class="hl std"> { </span><span class="hl kwc">APOSTROPHE</span><span class="hl std"> }
    | </span><span class="">eof</span><span class="hl std"> { </span><span class="hl kwc">EOF</span><span class="hl std"> }
    | </span><span class="hl num">_</span><span class="hl std"> { </span><span class="">raise</span><span class="hl std"> (</span><span class="hl kwc">SyntaxError</span><span class="hl std"> (</span><span class="hl str">&quot;Unexpected char: &quot;</span><span class="hl std"> ^ </span><span class="hl kwc">Lexing</span><span class="hl std">.</span><span class="">lexeme</span><span class="hl std"> </span><span class="">lexbuf</span><span class="hl std">)) }
</span></pre>
<p>
These tokens must be fed to a parser, which recognizes token structures as Prolog terms and returns the appropriate OCaml types. In order to write the parsing rules, we will take a little detour to write our types.
</p>
<pre class="code-ocaml"><span class="hl kwa">type</span><span class="hl std"> </span><span class="">varN</span><span class="hl std"> = </span><span class="hl kwd">string</span><span class="hl std">
</span><span class="hl kwa">type</span><span class="hl std"> </span><span class="">opN</span><span class="hl std"> = </span><span class="hl kwd">string</span><span class="hl std">
</span><span class="hl kwa">type</span><span class="hl std"> </span><span class="">term</span><span class="hl std"> = 
    | </span><span class="hl kwc">Var</span><span class="hl std"> </span><span class="hl kwa">of</span><span class="hl std"> </span><span class="">varN</span><span class="hl std">
    | </span><span class="hl kwc">Const</span><span class="hl std"> </span><span class="hl kwa">of</span><span class="hl std"> </span><span class="">varN</span><span class="hl std">
    | </span><span class="hl kwc">Op</span><span class="hl std"> </span><span class="hl kwa">of</span><span class="hl std"> </span><span class="">opN</span><span class="hl std"> * (</span><span class="">term</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std">)

</span><span class="hl kwa">type</span><span class="hl std"> </span><span class="">sub</span><span class="hl std"> = (</span><span class="">varN</span><span class="hl std"> * </span><span class="">term</span><span class="hl std">) </span><span class="hl kwd">list</span><span class="hl std">

</span><span class="hl kwa">type</span><span class="hl std"> </span><span class="">clause</span><span class="hl std"> = { </span><span class="">head</span><span class="hl std"> : </span><span class="">term</span><span class="hl std"> ; </span><span class="">body</span><span class="hl std"> : </span><span class="">term</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std"> }
</span></pre>
<p>
In the simple program mentioned before, <span class="icode"><span class="hl kwd">mother_child</span><span class="hl opt">(</span>trude<span class="hl opt">,</span> sally<span class="hl opt">)</span></span>. will be a variant term of tag <span class="icode"><span class="hl kwc">Op</span></span> in the form <span class="icode"><span class="hl std">(</span><span class="hl str">&quot;mother_child&quot;</span><span class="hl std">,[</span><span class="hl kwc">Const</span><span class="hl std"> </span><span class="hl str">&quot;trude&quot;</span><span class="hl std">;  </span><span class="hl kwc">Const</span><span class="hl std"> </span><span class="hl str">&quot;sally&quot;</span><span class="hl std">])</span></span>. It will be stored in the database as a clause record in the form  <span class="icode"><span class="hl std">{ </span><span class="">head</span><span class="hl std"> = </span><span class="hl kwc">Op</span><span class="hl std">  (</span><span class="hl str">&quot;mother_child&quot;</span><span class="hl std">, [</span><span class="hl kwc">Const</span><span class="hl std"> </span><span class="hl str">&quot;trude&quot;</span><span class="hl std">; </span><span class="hl kwc">Const</span><span class="hl std"> </span><span class="hl str">&quot;sally&quot;</span><span class="hl std">]) ; </span><span class="">body</span><span class="hl std"> = [] }</span></span>. This is called a 'fact', a clause which we know to be true without needing to prove a body of other terms. The following clause,
</p>
<pre class="code-pro"><span class="hl kwd">parent_child</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">) :-</span> <span class="hl kwd">father_child</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">).</span></pre>
<p>
is a rule, because it is only true if <span class="icode"><span class="hl kwd">father_child</span><span class="hl opt">(</span>X<span class="hl opt">,</span> Y<span class="hl opt">).</span></span> is true. 
</p>
<p>
Now we can write our parser rules. Reading a Prolog program will yield a list of clauses. We assume that what we read through our prompt is a query, whereas what we read from files is to be loaded into our database.
</p>
<pre class="code-ocaml"><span class="">main</span><span class="hl std">:
    | </span><span class="hl kwc">EOF</span><span class="hl std"> { [] }
    | </span><span class="">clause</span><span class="hl std"> { $</span><span class="hl num">1</span><span class="hl std"> }

</span><span class="">clause</span><span class="hl std">:
    | </span><span class="">rule</span><span class="hl std"> </span><span class="">main</span><span class="hl std"> { $</span><span class="hl num">1</span><span class="hl std"> :: $</span><span class="hl num">2</span><span class="hl std"> }

</span><span class="">rule</span><span class="hl std">:
    | </span><span class="hl kwc">LBRACKET</span><span class="hl std"> </span><span class="">v</span><span class="hl std"> = </span><span class="hl kwc">VAR</span><span class="hl std"> </span><span class="hl kwc">RBRACKET</span><span class="hl std"> </span><span class="hl kwc">PERIOD</span><span class="hl std"> 
    | </span><span class="hl kwc">LBRACKET</span><span class="hl std"> </span><span class="">v</span><span class="hl std"> = </span><span class="hl kwc">CONST</span><span class="hl std"> </span><span class="hl kwc">RBRACKET</span><span class="hl std"> </span><span class="hl kwc">PERIOD</span><span class="hl std"> { { </span><span class="">head</span><span class="hl std"> = (</span><span class="hl kwc">Op</span><span class="hl std"> (</span><span class="hl str">&quot;assert&quot;</span><span class="hl std">,[(</span><span class="hl kwc">Var</span><span class="hl std"> </span><span class="">v</span><span class="hl std">)])); </span><span class="">body</span><span class="hl std">=[] } }
    | </span><span class="hl kwc">CONST</span><span class="hl std"> </span><span class="hl kwc">PERIOD</span><span class="hl std"> { { </span><span class="">head</span><span class="hl std">=(</span><span class="hl kwc">Op</span><span class="hl std"> ($</span><span class="hl num">1</span><span class="hl std">,[])); </span><span class="">body</span><span class="hl std">=[] } }
    | </span><span class="hl kwc">CONST</span><span class="hl std"> </span><span class="hl kwc">LPAREN</span><span class="hl std"> </span><span class="">arguments</span><span class="hl std"> </span><span class="hl kwc">RPAREN</span><span class="hl std"> </span><span class="hl kwc">PERIOD</span><span class="hl std"> { { </span><span class="">head</span><span class="hl std"> = (</span><span class="hl kwc">Op</span><span class="hl std"> ($</span><span class="hl num">1</span><span class="hl std">,$</span><span class="hl num">3</span><span class="hl std">)); </span><span class="">body</span><span class="hl std"> = [] } }
    | </span><span class="hl kwc">CONST</span><span class="hl std"> </span><span class="hl kwc">LPAREN</span><span class="hl std"> </span><span class="">arguments</span><span class="hl std"> </span><span class="hl kwc">RPAREN</span><span class="hl std"> </span><span class="hl kwc">COLON</span><span class="hl std"> </span><span class="hl kwc">DASH</span><span class="hl std"> </span><span class="">goals</span><span class="hl std"> </span><span class="hl kwc">PERIOD</span><span class="hl std"> { { </span><span class="">head</span><span class="hl std">=(</span><span class="hl kwc">Op</span><span class="hl std"> ($</span><span class="hl num">1</span><span class="hl std">,$</span><span class="hl num">3</span><span class="hl std">)) ; </span><span class="">body</span><span class="hl std">= $</span><span class="hl num">7</span><span class="hl std"> } }

</span><span class="">goals</span><span class="hl std">:
    | </span><span class="">goal</span><span class="hl std"> { [$</span><span class="hl num">1</span><span class="hl std">] }
    | </span><span class="">goal</span><span class="hl std"> </span><span class="hl kwc">COMMA</span><span class="hl std"> </span><span class="">goals</span><span class="hl std"> { $</span><span class="hl num">1</span><span class="hl std"> :: $</span><span class="hl num">3</span><span class="hl std"> }

</span><span class="">goal</span><span class="hl std">:
    | </span><span class="hl kwc">CONST</span><span class="hl std"> </span><span class="hl kwc">LPAREN</span><span class="hl std"> </span><span class="">arguments</span><span class="hl std"> </span><span class="hl kwc">RPAREN</span><span class="hl std"> { </span><span class="hl kwc">Op</span><span class="hl std"> ($</span><span class="hl num">1</span><span class="hl std">,$</span><span class="hl num">3</span><span class="hl std">) } 

</span><span class="">arguments</span><span class="hl std">:
    | </span><span class="">term</span><span class="hl std"> { [$</span><span class="hl num">1</span><span class="hl std">] }
    | </span><span class="">term</span><span class="hl std"> </span><span class="hl kwc">COMMA</span><span class="hl std"> </span><span class="">arguments</span><span class="hl std"> { $</span><span class="hl num">1</span><span class="hl std"> :: $</span><span class="hl num">3</span><span class="hl std"> }

</span><span class="">term</span><span class="hl std">:
    | </span><span class="hl kwc">APOSTROPHE</span><span class="hl std"> </span><span class="hl kwc">CONST</span><span class="hl std"> </span><span class="hl kwc">APOSTROPHE</span><span class="hl std"> { </span><span class="hl kwc">Const</span><span class="hl std"> $</span><span class="hl num">2</span><span class="hl std"> } 
    | </span><span class="hl kwc">CONST</span><span class="hl std"> { </span><span class="hl kwc">Const</span><span class="hl std"> $</span><span class="hl num">1</span><span class="hl std"> }
    | </span><span class="hl kwc">VAR</span><span class="hl std"> { </span><span class="hl kwc">Var</span><span class="hl std"> $</span><span class="hl num">1</span><span class="hl std"> }
    | </span><span class="">goal</span><span class="hl std"> { $</span><span class="hl num">1</span><span class="hl std"> }
</span></pre>
<h3> unification </h3>
<p>We use the unification algorithm from <a href="https://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec26-type-inference/type-inference.htm#unify">this page</a>. We will use this code to find the most general unifier in the following solving process. </p>

<pre class="code-txt"><span class="hl std">function resolution(clause, goals, query):
let sub = the MGU of head(clause) and head(goals)
return (sub(tail(clause) concatenated with tail(goals)), sub(query))

function solve(goals, query):
if goals is empty then succeed(query)
else for each clause c in the program, in order,
if head(c) does not unify with head(goals) then do nothing 
else solve(resolution(c, goals, query))
</span></pre>
<p>In OCaml this will be:</p>
<pre class="code-ocaml"><span class="hl com">(* get predicate notation f and return list of database entries *)</span><span class="hl std">
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">predicate</span><span class="hl std"> </span><span class="">f</span><span class="hl std"> =
    </span><span class="hl kwb">try</span><span class="hl std"> </span><span class="hl kwc">List</span><span class="hl std">.</span><span class="">rev</span><span class="hl std"> (</span><span class="hl kwc">Hashtbl</span><span class="hl std">.</span><span class="">find_all</span><span class="hl std"> </span><span class="">prog</span><span class="hl std"> </span><span class="">f</span><span class="hl std">) </span><span class="hl com">(* Hashtbl.find_all returns most recent entries first *)</span><span class="hl std">
    </span><span class="hl kwb">with</span><span class="hl std"> </span><span class="hl kwc">Not_found</span><span class="hl std"> -&gt; </span><span class="">raise</span><span class="hl std"> </span><span class="hl kwc">No_pred</span><span class="hl std">

</span><span class="hl com">(* lapply applies substitution to lists of terms, apply to terms *)</span><span class="hl std">
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">resolution</span><span class="hl std"> </span><span class="">clause</span><span class="hl std"> (</span><span class="">b</span><span class="hl std">::</span><span class="">gs</span><span class="hl std">) </span><span class="">q</span><span class="hl std"> =
    </span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">u</span><span class="hl std"> = </span><span class="">unify</span><span class="hl std"> [(</span><span class="">clause</span><span class="hl std">.</span><span class="">head</span><span class="hl std">,</span><span class="">b</span><span class="hl std">)] </span><span class="hl kwa">in</span><span class="hl std">
    (</span><span class="">lapply</span><span class="hl std"> </span><span class="">u</span><span class="hl std"> (</span><span class="">clause</span><span class="hl std">.</span><span class="">body</span><span class="hl std"> @ </span><span class="">gs</span><span class="hl std">), </span><span class="">apply</span><span class="hl std"> </span><span class="">u</span><span class="hl std"> </span><span class="">q</span><span class="hl std">)

</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="hl kwa">rec</span><span class="hl std"> </span><span class="">solve</span><span class="hl std"> (</span><span class="">g</span><span class="hl std"> : </span><span class="">term</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std">) (</span><span class="">query</span><span class="hl std"> : </span><span class="">term</span><span class="hl std">)  = 
    </span><span class="hl kwb">match</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> </span><span class="hl kwb">with</span><span class="hl std">
    | [] -&gt; </span><span class="">query</span><span class="hl std">
    | </span><span class="">x</span><span class="hl std">::</span><span class="">xs</span><span class="hl std"> </span><span class="hl kwb">as</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> -&gt; </span><span class="hl kwb">match</span><span class="hl std"> (</span><span class="">predicate</span><span class="hl std"> (</span><span class="">notate</span><span class="hl std"> </span><span class="">x</span><span class="hl std">)) </span><span class="hl kwb">with</span><span class="hl std">
                | [] -&gt; </span><span class="">raise</span><span class="hl std"> (</span><span class="hl kwc">No_solution</span><span class="hl std"> </span><span class="hl str">&quot;no clauses left&quot;</span><span class="hl std">)
                | ((</span><span class="">a</span><span class="hl std">::</span><span class="">cs</span><span class="hl std">) :</span><span class="">clause</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std">) -&gt; </span><span class="hl kwb">try</span><span class="hl std"> (</span><span class="hl kwb">match</span><span class="hl std"> </span><span class="">resolution</span><span class="hl std"> </span><span class="">a</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> </span><span class="">query</span><span class="hl std"> </span><span class="hl kwb">with</span><span class="hl std">
                                            | ([],</span><span class="">newq</span><span class="hl std">) -&gt; </span><span class="">solve</span><span class="hl std"> [] </span><span class="">newq</span><span class="hl std">
                                            | (</span><span class="">newg</span><span class="hl std">,</span><span class="">newq</span><span class="hl std">) -&gt; </span><span class="">solve</span><span class="hl std"> </span><span class="">newg</span><span class="hl std"> </span><span class="">newq</span><span class="hl std">
                                            </span><span class="hl kwb">with</span><span class="hl std"> </span><span class="hl kwc">No_unify</span><span class="hl std"> </span><span class="hl num">_</span><span class="hl std"> -&gt; </span><span class="">solve</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> </span><span class="">query</span><span class="hl std">
</span></pre>
<p>We can then call <span class="icode"><span class="hl std">solve</span></span> and if it returns a result, unify it with the original query and show the result. To support backtracking and also check other clauses in case of failure, we have to keep the clauses we have not looked at everytime we pick a path in the clause database. In addition, to avoid trouble with recursion and variable name conflict in general, we have to rename our variables to keep them different in each call of solve. This can be done by assigning <span class="icode"><span class="hl std">solve</span></span>'s recursion level as a suffix</p>
<pre class="code-ocaml"><span class="hl com">(* renames variables to avoid confusion in case of identical variable names *)</span><span class="hl std">
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">rename_depth</span><span class="hl std"> </span><span class="">n</span><span class="hl std"> </span><span class="">c</span><span class="hl std"> =
    </span><span class="hl kwa">let</span><span class="hl std"> </span><span class="hl kwa">rec</span><span class="hl std"> </span><span class="">aux</span><span class="hl std"> = </span><span class="hl kwa">function</span><span class="hl std">
        </span><span class="hl kwc">Var</span><span class="hl std"> </span><span class="">x</span><span class="hl std"> -&gt; </span><span class="hl kwc">Var</span><span class="hl std"> (</span><span class="">x</span><span class="hl std"> ^ </span><span class="hl str">&quot;__&quot;</span><span class="hl std"> ^ (</span><span class="">string_of_int</span><span class="hl std"> </span><span class="">n</span><span class="hl std">))
        | </span><span class="hl kwc">Const</span><span class="hl std"> </span><span class="">x</span><span class="hl std"> -&gt; </span><span class="hl kwc">Const</span><span class="hl std"> </span><span class="">x</span><span class="hl std">
        | </span><span class="hl kwc">Op</span><span class="hl std"> (</span><span class="">x</span><span class="hl std">,</span><span class="">y</span><span class="hl std">) -&gt; </span><span class="hl kwc">Op</span><span class="hl std"> (</span><span class="">x</span><span class="hl std">, (</span><span class="hl kwc">List</span><span class="hl std">.</span><span class="">map</span><span class="hl std"> </span><span class="">aux</span><span class="hl std"> </span><span class="">y</span><span class="hl std">))
    </span><span class="hl kwa">in</span><span class="hl std"> { </span><span class="">head</span><span class="hl std"> = (</span><span class="">aux</span><span class="hl std"> </span><span class="">c</span><span class="hl std">.</span><span class="">head</span><span class="hl std">) ; </span><span class="">body</span><span class="hl std"> = (</span><span class="hl kwc">List</span><span class="hl std">.</span><span class="">map</span><span class="hl std"> </span><span class="">aux</span><span class="hl std"> </span><span class="">c</span><span class="hl std">.</span><span class="">body</span><span class="hl std">) }

</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">resolution</span><span class="hl std"> </span><span class="">clause</span><span class="hl std"> (</span><span class="">b</span><span class="hl std">::</span><span class="">gs</span><span class="hl std">) </span><span class="">q</span><span class="hl std"> =
    </span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">u</span><span class="hl std"> = </span><span class="">unify</span><span class="hl std"> [(</span><span class="">clause</span><span class="hl std">.</span><span class="">head</span><span class="hl std">,</span><span class="">b</span><span class="hl std">)] </span><span class="hl kwa">in</span><span class="hl std">
    (</span><span class="">lapply</span><span class="hl std"> </span><span class="">u</span><span class="hl std"> (</span><span class="">clause</span><span class="hl std">.</span><span class="">body</span><span class="hl std"> @ </span><span class="">gs</span><span class="hl std">), </span><span class="">apply</span><span class="hl std"> </span><span class="">u</span><span class="hl std"> </span><span class="">q</span><span class="hl std">)

</span><span class="hl com">(* (g = goals list, q = query, clausesleft, n = depth level, ch = choices list *)</span><span class="hl std">
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="hl kwa">rec</span><span class="hl std"> </span><span class="">solve</span><span class="hl std"> (</span><span class="">g</span><span class="hl std"> : </span><span class="">term</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std">) (</span><span class="">query</span><span class="hl std"> : </span><span class="">term</span><span class="hl std">) (</span><span class="">cls</span><span class="hl std"> : </span><span class="">clause</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std">) (</span><span class="">n</span><span class="hl std"> : </span><span class="hl kwd">int</span><span class="hl std">) (</span><span class="">ch</span><span class="hl std"> : (</span><span class="">term</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std"> * </span><span class="">term</span><span class="hl std"> * </span><span class="">clause</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std"> * </span><span class="hl kwd">int</span><span class="hl std">) </span><span class="hl kwd">list</span><span class="hl std">) = 
    </span><span class="hl kwb">match</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> </span><span class="hl kwb">with</span><span class="hl std">
    | [] -&gt; (</span><span class="">query</span><span class="hl std">,</span><span class="">ch</span><span class="hl std">)
    | </span><span class="">x</span><span class="hl std">::</span><span class="">xs</span><span class="hl std"> </span><span class="hl kwb">as</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> -&gt; </span><span class="hl kwb">match</span><span class="hl std"> </span><span class="">cls</span><span class="hl std"> </span><span class="hl kwb">with</span><span class="hl std">
                | [] -&gt; </span><span class="">next_choice</span><span class="hl std"> </span><span class="">ch</span><span class="hl std"> </span><span class="hl com">(*raise (No_solution &quot;no clauses left&quot;) *)</span><span class="hl std">
                | ((</span><span class="">a</span><span class="hl std">::</span><span class="">cs</span><span class="hl std">) :</span><span class="">clause</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std">) -&gt; </span><span class="hl kwb">try</span><span class="hl std"> (</span><span class="hl kwb">match</span><span class="hl std"> </span><span class="">resolution</span><span class="hl std"> (</span><span class="">rename_depth</span><span class="hl std"> </span><span class="">n</span><span class="hl std"> </span><span class="">a</span><span class="hl std">) </span><span class="">g</span><span class="hl std"> </span><span class="">query</span><span class="hl std"> </span><span class="hl kwb">with</span><span class="hl std">
                                            | ([],</span><span class="">newq</span><span class="hl std">) -&gt; </span><span class="">solve</span><span class="hl std"> [] </span><span class="">newq</span><span class="hl std"> </span><span class="">cs</span><span class="hl std"> (</span><span class="">n</span><span class="hl num">+1</span><span class="hl std">) ((</span><span class="">g</span><span class="hl std">,</span><span class="">query</span><span class="hl std">,</span><span class="">cs</span><span class="hl std">,</span><span class="">n</span><span class="hl std">)::</span><span class="">ch</span><span class="hl std">)
                                            | (</span><span class="">newg</span><span class="hl std">,</span><span class="">newq</span><span class="hl std">) -&gt; </span><span class="">solve</span><span class="hl std"> </span><span class="">newg</span><span class="hl std"> </span><span class="">newq</span><span class="hl std"> (</span><span class="">predicate</span><span class="hl std"> (</span><span class="">notate</span><span class="hl std"> (</span><span class="hl kwc">List</span><span class="hl std">.</span><span class="">hd</span><span class="hl std"> </span><span class="">newg</span><span class="hl std">))) (</span><span class="">n</span><span class="hl num">+1</span><span class="hl std">) ((</span><span class="">g</span><span class="hl std">,</span><span class="">query</span><span class="hl std">,</span><span class="">cs</span><span class="hl std">,</span><span class="">n</span><span class="hl std">)::</span><span class="">ch</span><span class="hl std">)) 
                                            </span><span class="hl kwb">with</span><span class="hl std"> </span><span class="hl kwc">No_unify</span><span class="hl std"> </span><span class="hl num">_</span><span class="hl std"> -&gt; </span><span class="">solve</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> </span><span class="">query</span><span class="hl std"> </span><span class="">cs</span><span class="hl std"> </span><span class="">n</span><span class="hl std"> </span><span class="">ch</span><span class="hl std">
</span><span class="hl kwa">and</span><span class="hl std"> </span><span class="">next_choice</span><span class="hl std"> = </span><span class="hl kwa">function</span><span class="hl std"> </span><span class="hl com">(* gets next path in predicate database - backtracking *)</span><span class="hl std">
      [] -&gt; </span><span class="">raise</span><span class="hl std"> (</span><span class="hl kwc">No_solution</span><span class="hl std"> </span><span class="hl str">&quot;No choices left&quot;</span><span class="hl std">)
    | (</span><span class="">g</span><span class="hl std">, </span><span class="">q</span><span class="hl std">, </span><span class="">cls</span><span class="hl std">, </span><span class="">n</span><span class="hl std">)::</span><span class="">tl</span><span class="hl std"> -&gt; </span><span class="">solve</span><span class="hl std"> </span><span class="">g</span><span class="hl std"> </span><span class="">q</span><span class="hl std"> </span><span class="">cls</span><span class="hl std"> </span><span class="">n</span><span class="hl std"> </span><span class="">tl</span><span class="hl std">

</span><span class="hl com">(* unify result with query, if substitution = [] then print yes, otherwise print the substitution. *)</span><span class="hl std">
</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="hl kwa">rec</span><span class="hl std"> </span><span class="">success</span><span class="hl std"> (</span><span class="">result</span><span class="hl std">,</span><span class="">choices</span><span class="hl std">) </span><span class="">query</span><span class="hl std"> = 
    </span><span class="hl kwa">let</span><span class="hl std"> </span><span class="hl kwa">rec</span><span class="hl std"> </span><span class="">print_bindings</span><span class="hl std"> = </span><span class="hl kwa">function</span><span class="hl std">
        [] -&gt; ()
        | (</span><span class="">x</span><span class="hl std">,</span><span class="">y</span><span class="hl std">)::</span><span class="">tl</span><span class="hl std"> -&gt; </span><span class="">print_string</span><span class="hl std"> (</span><span class="hl str">&quot; &quot;</span><span class="hl std"> ^ </span><span class="">x</span><span class="hl std"> ^ </span><span class="hl str">&quot; = &quot;</span><span class="hl std">) ; </span><span class="">print_term</span><span class="hl std"> [</span><span class="">y</span><span class="hl std">] ; </span><span class="">print_bindings</span><span class="hl std"> </span><span class="">tl</span><span class="hl std">
    </span><span class="hl kwa">in</span><span class="hl std"> </span><span class="hl kwb">match</span><span class="hl std"> </span><span class="">unify_one</span><span class="hl std"> </span><span class="">result</span><span class="hl std"> </span><span class="">query</span><span class="hl std"> </span><span class="hl kwb">with</span><span class="hl std">
                        | [] -&gt; </span><span class="">print_endline</span><span class="hl std"> </span><span class="hl str">&quot;yes.&quot;</span><span class="hl std">
                        | </span><span class="hl kwd">list</span><span class="hl std"> -&gt; </span><span class="">print_bindings</span><span class="hl std"> </span><span class="hl kwd">list</span><span class="hl std"> ; </span><span class="hl kwb">try</span><span class="hl std"> </span><span class="hl kwb">match</span><span class="hl std"> </span><span class="">read_line</span><span class="hl std"> () </span><span class="hl kwb">with</span><span class="hl std"> </span><span class="hl com">(* search for next choice if user requests with ';\n' *)</span><span class="hl std">
                                                            | </span><span class="hl str">&quot;;&quot;</span><span class="hl std"> -&gt; </span><span class="">success</span><span class="hl std"> (</span><span class="">next_choice</span><span class="hl std"> </span><span class="">choices</span><span class="hl std">) </span><span class="">query</span><span class="hl std"> ; ()
                                                            | </span><span class="hl num">_</span><span class="hl std"> -&gt; </span><span class="">print_string</span><span class="hl std"> </span><span class="hl str">&quot;&quot;</span><span class="hl std">
                                                        </span><span class="hl kwb">with</span><span class="hl std"> (</span><span class="hl kwc">No_solution</span><span class="hl std"> </span><span class="hl num">_</span><span class="hl std">) -&gt; </span><span class="">print_string</span><span class="hl std"> </span><span class="hl str">&quot;&quot;</span><span class="hl std">

</span><span class="hl kwa">let</span><span class="hl std"> </span><span class="">solve_prompt</span><span class="hl std"> </span><span class="">q</span><span class="hl std"> = </span><span class="hl kwb">try</span><span class="hl std"> </span><span class="">success</span><span class="hl std"> (</span><span class="">solve</span><span class="hl std"> [</span><span class="">q</span><span class="hl std">] </span><span class="">q</span><span class="hl std"> (</span><span class="">predicate</span><span class="hl std"> (</span><span class="">notate</span><span class="hl std"> </span><span class="">q</span><span class="hl std">)) </span><span class="hl num">0</span><span class="hl std"> []) </span><span class="">q</span><span class="hl std">
                    </span><span class="hl kwb">with</span><span class="hl std"> (</span><span class="hl kwc">No_solution</span><span class="hl std"> </span><span class="hl num">_</span><span class="hl std">) -&gt; </span><span class="">print_endline</span><span class="hl std"> </span><span class="hl str">&quot;no.&quot;</span><span class="hl std"> 
</span></pre>
<p>This implementation is fairly plain with no support for integers, lists, comparison operators and built-in predicates.</p>

    </div>
  </body>
</html>
